# 面试题

## 目录

1. 网络
2. Java 基础&容器&同步&设计模式
3. Java 虚拟机&内存结构&GC&类加载&四种引用&动态代理

## 1、网络

### 网络协议模型

- 应用层：负责处理特定的应用程序细节。HTTP、FTP、DNS
- 传输层：为两台主机提供端到端的基础通信。TCP、UDP
- 网络层：控制分组传输、路由选择等。IP
- 链路层：操作系统设备驱动程序、网卡相关接口。

### TCP 和 UDP 区别

TCP 连接；可靠；有序；面向字节流；速度慢；较重量；全双工；适用于文件传输、浏览器等
- 全双工：A 给 B 发消息的同时，B 也能给 A 发
- 半双工：A 给 B 发消息的同时，B 不能给 A 发

UDP 无连接；不可靠；无序；面向报文；速度快；轻量；适用于即时通讯、视频通话等

TCP 三次握手
- A：你能听到吗？
- B：我能听到，你能听到吗？
- A：我能听到，开始吧

A 和 B 两方都要能确保：我说的话，你能听到；你说的话，我能听到。所以需要三次握手

TCP 四次挥手
- A：我说完了
- B：我知道了，等一下，我可能还没说完
- B：我也说完了
- A：我知道了，结束吧

B 收到 A 结束的消息后 B 可能还没说完，没法立即回复结束标示，只能等说完后再告诉 A ：我说完了。

### POST 和 GET 区别

- Get 参数放在 url 中；Post 参数放在 request Body 中
- Get 可能不安全，因为参数放在 url 中

### HTTPS

- HTTP 是超文本传输协议，明文传输；HTTPS 使用 SSL 协议对 HTTP 传输数据进行了加密
- HTTP 默认 80 端口；HTTPS 默认 443 端口
- 优点：安全
- 缺点：费时、SSL 证书收费，加密能力还是有限的，但是比 HTTP 强多了

## 2、Java 基础&容器&同步&设计模式

### StringBuilder、StringBuffer、+、String.concat 链接字符串：

- StringBuffer 线程安全，StringBuilder 线程不安全
- +实际上是用 StringBuilder 来实现的，所以非循环体可以直接用 +，循环体不行，因为会频繁创建 - StringBuilder
- String.concat 实质是 new String ，效率也低，耗时排序：StringBuilder < StringBuffer < concat < +

### Java 泛型擦除

- 修饰成员变量等类结构相关的泛型不会被擦除
- 容器类泛型会被擦除

### ArrayList、LinkedList

#### ArrayList
基于数组实现，查找快：o(1)，增删慢：o(n)
初始容量为10，扩容通过 System.arrayCopy 方法

#### LinkedList
基于双向链表实现，查找慢：o(n)，增删快：o(1)
封装了队列和栈的调用

### HashMap 、HashTable

#### HashMap

基于数组和链表实现，数组是 HashMap 的主体；链表是为解决哈希冲突而存在的
当发生哈希冲突且链表 size 大于阈值时会扩容，JAVA 8 会将链表转为红黑树提高性能
允许 key/value 为 null

#### HashTable

数据结构和 HashMap 一样
不允许 value 为 null
线程安全

### ArrayMap、SparseArray

#### ArrayMap

1. 基于两个数组实现，一个存放 hash；一个存放键值对。扩容的时候只需要数组拷贝，不需要重建哈希表
2. 内存利用率高
3. 不适合存大量数据，因为会对 key 进行二分法查找（1000以下）

#### SparseArray

1.基于两个数组实现，int 做 key
2.内存利用率高
3.不适合存大量数据，因为会对 key 进行二分法查找（1000以下）

### volatile 关键字

- 只能用来修饰变量，适用修饰可能被多线程同时访问的变量
- 相当于轻量级的 synchronized，volatitle 能保证有序性（禁用指令重排序）、可见性；后者还能保证原子性
- 变量位于主内存中，每个线程还有自己的工作内存，变量在自己线程的工作内存中有份拷贝，线程直接操作的是这个拷贝
- 被 volatile 修饰的变量改变后会立即同步到主内存，保持变量的可见性。

### 双重检查单例，为什么要加 volatile？

1. volatile想要解决的问题是，在另一个线程中想要使用instance，发现instance!=null，但是实际上instance还未初始化完毕这个问题
2. 将instance =newInstance();拆分为3句话是。1.分配内存2.初始化3.将instance指向分配的内存空
3. volatile可以禁止指令重排序，确保先执行2，后执行3

### wait 和 sleep

- sleep 是 Thread 的静态方法，可以在任何地方调用
- wait 是 Object 的成员方法，只能在 synchronized 代码块中调用，否则会报 IllegalMonitorStateException 非法监控状态异常
- sleep 不会释放共享资源锁，wait 会释放共享资源锁

### lock 和 synchronized

- synchronized 是 Java 关键字，内置特性；Lock 是一个接口
- synchronized 会自动释放锁；lock 需要手动释放，所以需要写到 try catch 块中并在 finally 中释放锁
- synchronized 无法中断等待锁；lock 可以中断
- Lock 可以提高多个线程进行读/写操作的效率
- 竞争资源激烈时，lock 的性能会明显的优于 synchronized

### 可重入锁

- 定义：已经获取到锁后，再次调用同步代码块/尝试获取锁时不必重新去申请锁，可以直接执行相关代码
- ReentrantLock 和 synchronized 都是可重入锁

### 公平锁

- 定义：等待时间最久的线程会优先获得锁
- 非公平锁无法保证哪个线程获取到锁，synchronized 就是非公平锁
- ReentrantLock 默认时非公平锁，可以设置为公平锁

### 乐观锁和悲观锁

- 悲观锁：线程一旦得到锁，其他线程就挂起等待，适用于写入操作频繁的场景；synchronized 就是悲观锁
- 乐观锁：假设没有冲突，不加锁，更新数据时判断该数据是否过期，过期的话则不进行数据更新，适用于读取操作频繁的场景
- 乐观锁 CAS：Compare And Swap，更新数据时先比较原值是否相等，不相等则表示数据过去，不进行数据更新
- 乐观锁实现：AtomicInteger、AtomicLong、AtomicBoolean

### 死锁 4 个必要条件

- 互斥
- 占有且等待
- 不可抢占
- 循环等待

### synchronized 原理

- 每个对象都有一个监视器锁：monitor，同步代码块会执行 monitorenter 开始，motnitorexit 结束
- wait/notify 就依赖 monitor 监视器，所以在非同步代码块中执行会报 IllegalMonitorStateException 异常

## 3、Java 虚拟机&内存结构&GC&类加载&四种引用&动态代理

### JVM

- 定义：可以理解成一个虚构的计算机，解释自己的字节码指令集映射到本地 CPU 或 OS 的指令集，上层只需关注 Class 文件，与操作系统无关，实现跨平台
- Kotlin 就是能解释成 Class 文件，所以可以跑在 JVM 上

### JVM 内存模型

- Java 多线程之间是通过共享内存来通信的，每个线程都有自己的本地内存
- 共享变量存放于主内存中，线程会拷贝一份共享变量到本地内存
- volatile 关键字就是给内存模型服务的，用来保证内存可见性和顺序性

### JVM 内存结构

#### 线程私有：

1. 程序计数器：记录正在执行的字节码指令地址，若正在执行 Native 方法则为空
2. 虚拟机栈：执行方法时把方法所需数据存为一个栈帧入栈，执行完后出栈
3. 本地方法栈：同虚拟机栈，但是针对的是 Native 方法

#### 线程共享：

1. 堆：存储 Java 实例，GC 主要区域，分代收集 GC 方法会吧堆划分为新生代、老年代
2. 方法区：存储类信息，常量池，静态变量等数据

### GC

回收区域：只针对堆、方法区；线程私有区域数据会随线程结束销毁，不用回收

### 回收类型：

1. 堆中的对象
    - 分代收集 GC 方法会吧堆划分为新生代、老年代
    - 新生代：新建小对象会进入新生代；通过复制算法回收对象
    - 老年代：新建大对象及老对象会进入老年代；通过标记-清除算法回收对象
2. 方法区中的类信息、常量池

### 判断一个对象是否可被回收：

1. 引用计数法
    - 缺点：循环引用
2. 可达性分析法
    - 定义：从 GC ROOT 开始搜索，不可达的对象都是可以被回收的

### GC ROOT

1. 虚拟机栈/本地方法栈中引用的对象
2. 方法区中常量/静态变量引用的对象

### 四种引用

- 强引用：不会被回收
- 软引用：内存不足时会被回收
- 弱引用：gc 时会被回收
- 虚引用：无法通过虚引用得到对象，可以监听对象的回收

### ClassLoader

#### 类的生命周期：

1.加载；2.验证；3.准备；4.解析；5.初始化；6.使用；7.卸载

#### 类加载过程：

1. 加载：获取类的二进制字节流；生成方法区的运行时存储结构；在内存中生成 Class 对象
2. 验证：确保该 Class 字节流符合虚拟机要求
3. 准备：初始化静态变量
4. 解析：将常量池的符号引用替换为直接引用
5. 初始化：执行静态块代码、类变量赋值

#### 类加载时机：

1. 实例化对象
2. 调用类的静态方法
3. 调用类的静态变量（放入常量池的常量除外）

#### 类加载器：负责加载 class 文件

分类：

1. 引导类加载器 - 没有父类加载器
2. 拓展类加载器 - 继承自引导类加载器
3. 系统类加载器 - 继承自拓展类加载器

#### 双亲委托模型：

- 当要加载一个 class 时，会先逐层向上让父加载器先加载，加载失败才会自己加载
- 为什么叫双亲？不考虑自定义加载器，系统类加载器需要网上询问两层，所以叫双亲
- 判断是否是同一个类时，除了类信息，还必须时同一个类加载器

优点：

- 防止重复加载，父加载器加载过了就没必要加载了
- 安全，防止篡改核心库类

### 动态代理原理及实现

- InvocationHandler 接口，动态代理类需要实现这个接口
- Proxy.newProxyInstance，用于动态创建代理对象
- Retrofit 应用： Retrofit 通过动态代理，为我们定义的请求接口都生成一个动态代理对象，实现请求

